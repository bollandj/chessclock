/*
 * sound.c
 *
 * Created: 11/07/2020 13:08:17
 *  Author: Joshua
 */ 

#include "sound.h"

uint8_t beepTimer;
uint16_t beepFreq;

// notes C0 to B0 (right shift for higher octaves)
uint16_t const scale[12] PROGMEM = 
{
	// 64792,
	61155,
	57723,
	54483,
	51425,
	48539,
	45814,
	43243,
	40816,
	38525,
	36363,
	34322,
	32395
	// 30577
};

const uint8_t abc[270] PROGMEM = 
{
	0x58, 0x3a, 0x31, 0x0d, 0x0a, 0x54, 0x3a, 0x50, 0x61, 0x64, 0x64, 0x79,
	0x20, 0x4f, 0x27, 0x52, 0x61, 0x66, 0x66, 0x65, 0x72, 0x74, 0x79, 0x0d,
	0x0a, 0x43, 0x3a, 0x54, 0x72, 0x61, 0x64, 0x2e, 0x0d, 0x0a, 0x4d, 0x3a,
	0x36, 0x2f, 0x38, 0x0d, 0x0a, 0x4b, 0x3a, 0x44, 0x0d, 0x0a, 0x64, 0x66,
	0x66, 0x20, 0x63, 0x65, 0x65, 0x7c, 0x64, 0x65, 0x66, 0x20, 0x67, 0x66,
	0x65, 0x7c, 0x64, 0x66, 0x66, 0x20, 0x63, 0x65, 0x65, 0x7c, 0x64, 0x66,
	0x65, 0x20, 0x64, 0x42, 0x41, 0x7c, 0x64, 0x66, 0x66, 0x20, 0x63, 0x65,
	0x65, 0x7c, 0x64, 0x65, 0x66, 0x20, 0x67, 0x66, 0x65, 0x7c, 0x66, 0x61,
	0x66, 0x20, 0x67, 0x66, 0x65, 0x7c, 0x31, 0x20, 0x64, 0x66, 0x65, 0x20,
	0x64, 0x42, 0x41, 0x3a, 0x7c, 0x32, 0x20, 0x64, 0x66, 0x65, 0x20, 0x64,
	0x63, 0x42, 0x7c, 0x5d, 0x0d, 0x0a, 0x7e, 0x41, 0x33, 0x20, 0x42, 0x33,
	0x7c, 0x67, 0x66, 0x65, 0x20, 0x66, 0x64, 0x42, 0x7c, 0x41, 0x46, 0x41,
	0x20, 0x42, 0x32, 0x63, 0x7c, 0x64, 0x66, 0x65, 0x20, 0x64, 0x63, 0x42,
	0x7c, 0x7e, 0x41, 0x33, 0x20, 0x7e, 0x42, 0x33, 0x7c, 0x65, 0x66, 0x65,
	0x20, 0x65, 0x66, 0x67, 0x7c, 0x66, 0x61, 0x66, 0x20, 0x67, 0x66, 0x65,
	0x7c, 0x31, 0x20, 0x64, 0x66, 0x65, 0x20, 0x64, 0x63, 0x42, 0x3a, 0x7c,
	0x32, 0x20, 0x64, 0x66, 0x65, 0x20, 0x64, 0x42, 0x41, 0x7c, 0x5d, 0x0d,
	0x0a, 0x66, 0x41, 0x41, 0x20, 0x65, 0x41, 0x41, 0x7c, 0x64, 0x65, 0x66,
	0x20, 0x67, 0x66, 0x65, 0x7c, 0x66, 0x41, 0x41, 0x20, 0x65, 0x41, 0x41,
	0x7c, 0x64, 0x66, 0x65, 0x20, 0x64, 0x42, 0x41, 0x7c, 0x66, 0x41, 0x41,
	0x20, 0x65, 0x41, 0x41, 0x7c, 0x64, 0x65, 0x66, 0x20, 0x67, 0x66, 0x65,
	0x7c, 0x66, 0x61, 0x66, 0x20, 0x67, 0x66, 0x65, 0x7c, 0x64, 0x66, 0x65,
	0x20, 0x64, 0x42, 0x41, 0x3a, 0x7c
};

uint16_t abcPtr;
uint8_t unitNoteLength;
uint8_t key;

uint8_t duration;
uint16_t divisor;

// returns integer log 2, rounded down (i.e. highest bit set)
uint8_t int_log(uint8_t n)
{
	uint8_t r = 0;
	while (n >>= 1) r++;
	
	return r;		
}

// find next occurrence of c in file (ignoring spaces) and place pointer immediately after
// returns 0 if c found, -1 otherwise
int8_t skip_to(char t)
{
	char c;
	do 
	{
		c = get_char();
		
		if (c == t) return 0;
		else if (c == '\n') return -1; // only search up to end of line
				
	} while (c);
	
	return -1; // EOF reached
}

// get next character in file
char get_char()
{
	return pgm_read_byte(&abc[abcPtr++]);
}

// parse an integer (0<=n<=255)
uint8_t get_int()
{
	char c;
	uint8_t n, i;
	for (n = 0, i = 0; IS_DIGIT(c = get_char()) && i < 3; i++)
	{
		n *= 10;
		n += (c - '0');	
	}
	
	return n;
}

void read_header()
{
	unitNoteLength = 0;
	key = 0;
	
	abcPtr = 0;
	
	char c;
	for (; IS_ALPHA(c = get_char()); skip_to('\n')) // detect colon instead of alpha char
	{
		switch (c)
		{
			case 'L':
			case 'l':
			if(!skip_to(':')) // expected colon found
			{
				if(!skip_to('/')) // expected slash found
				{
					unitNoteLength = get_int(); // get unit note length
				}
			}
			break;
			
			case 'K':
			case 'k':
			if(!skip_to(':'))
			{
				
			}
			break;
			
			default:
			break;
		}
	}
	
	abcPtr--; // rewind pointer to start of line
}

void read_notes()
{
	char c;
	while ((c = get_char()))
	{
		uint8_t octave = 4;
		
		switch (c)
		{
			case ',':
			// octave--;
			break;
			
			case '\'':
			// octave++;
			break;
			
			case '_':
			break;
			
			case '=':
			break;
			
			case '^':
			break;
			
			case 'z':
			break;
			
			default:
			if (IS_LOWER(c))
			{
				uint8_t noteIndex = ((c - 'a') - 3) % 12;
				divisor = scale[noteIndex] >> octave;
				
				ICR1 = divisor;
				OCR1A = OCR1B = ICR1 >> 2;
				
				TCCR1B = 1<<WGM13 | 1<<WGM12 | 1<<CS11;
				_delay_ms(200);
				TCCR1B = 0x00;
				_delay_ms(25);
			}
			else if (IS_UPPER(c))
			{
				octave++;
				uint8_t noteIndex = ((c - 'A') - 3) % 12;
				divisor = scale[noteIndex] >> octave;
				
				ICR1 = divisor;
				OCR1A = OCR1B = ICR1 >> 2;
				
				TCCR1B = 1<<WGM13 | 1<<WGM12 | 1<<CS11;
				_delay_ms(200);
				TCCR1B = 0x00;
				_delay_ms(25);
			}
			break;
		}		
	}
}


void init_sound(void)
{
	DDRB |= 1<<PB1 | 1<<PB2; // OC1A, OC1B
	
	TCCR1A = 1<<COM1A1 | 1<<COM1B1 | 1<<COM1B0 | 1<<WGM11; // fast PWM, TOP = ICR1	
	TCCR1B = 1<<WGM13 | 1<<WGM12 | 1<<CS11;	               // /8 prescaler		
		
	beepTimer = 0;
	beepFreq = pgm_read_word(&scale[9]) >> 4; // A4
}

void update_beep(void)
{	
	if (beepTimer > 0) beepTimer--;
	else               TCCR1B = 0x00;		
}

void beep(uint8_t length)
{
	ICR1 = beepFreq;               // for some reason this can't be set just in the init function
	OCR1A = OCR1B = beepFreq >> 2; // 25% duty cycle
	beepTimer = length;
	TCCR1B = 1<<WGM13 | 1<<WGM12 | 1<<CS11;
}

void tune()
{		
	for (uint8_t i = 0; i < 8; i++)
	{		
		divisor = scale[9] >> 5;
		
		ICR1 = divisor;
		OCR1A = divisor >> 1;
		OCR1B = divisor >> 1;
		
		TCCR1B = 1<<WGM13 | 1<<WGM12 | 1<<CS11;
		_delay_ms(200);
		TCCR1B = 0x00;
		_delay_ms(25);
	}
}
